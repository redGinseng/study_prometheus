---

# 프로메테우스 학습 노트 - Chapter 3. 계측 (Instrumentation)

## 목차
- [프로메테우스 클라이언트 라이브러리](#프로메테우스-클라이언트-라이브러리)
- [메트릭 유형 및 사용법](#메트릭-유형-및-사용법)
- [히스토그램과 분위수](#히스토그램과-분위수)
- [유닛 테스트](#유닛-테스트)
- [계측 대상](#계측-대상)
- [계측 범위](#계측-범위)
- [메트릭 명명 규칙](#메트릭-명명-규칙)
- [퀴즈](#퀴즈)

---

## 프로메테우스 클라이언트 라이브러리

Prometheus 클라이언트 라이브러리는 Python, Java, Go, Rust, Ruby 등 다양한 언어에서 사용할 수 있습니다. 
교재에서는 Python을 예로 들어 설명하지만, 원칙적으로는 모든 언어에 적용됩니다.

## 메트릭 유형 및 사용법


- **카운터(Counter)**:
   - **사용법**: 카운터는 누적값을 측정하기 위해 사용됩니다. 예를 들어, 웹 사이트 방문 횟수나 완료된 트랜잭션 수 같은 연속적으로 증가하는 값을 추적할 때 사용합니다.
   - **주의사항**: 카운터는 감소하지 않으며, 시스템이 재시작되면 0으로 리셋됩니다.

- **게이지(Gauge)**:
   - **사용법**: 게이지는 특정 시점에서의 값을 측정합니다. 예를 들어, 현재 메모리 사용량이나 디스크 공간, 현재 처리 중인 요청 수 등을 나타낼 때 사용합니다.
   - **특징**: 게이지의 값은 시간에 따라 증가 또는 감소할 수 있습니다.

- **히스토그램(Histogram)**:
   - **사용법**: 히스토그램은 샘플들의 분포를 관찰하기 위해 사용됩니다. 예를 들어, 요청 처리 시간이나 응답 크기 등을 측정할 때 사용합니다.
   - **버킷**: 히스토그램은 값들을 버킷으로 분류하여, 각 버킷에 속하는 샘플 수를 추적합니다. 이를 통해 분위수나 평균, 중앙값 등을 계산할 수 있습니다.
   - **분위수의 한계**:
     - 계산 후 추가적인 수학 연산의 제한: 분위수를 계산한 후에는 이를 다른 수치와 더하거나 빼거나 평균을 내는 것이 통계학적으로 올바르지 않습니다. 분위수는 개별 데이터 포인트들의 위치를 나타내는 것으로, 이들을 직접적으로 수학적 연산에 사용하는 것은 적합하지 않습니다.
     - 디버깅 시의 제한: 예를 들어, 프론트엔드에서 지연 시간이 증가한 것이 관찰될 때, 그 원인이 되는 백엔드에서는 지연 시간이 증가하지 않았거나 오히려 감소했을 수 있습니다. 이러한 상황은 직관적으로 이해하기 어려울 수 있습니다.

### 평균값의 사용 권장

- **평균값의 장점**: 평균값은 더하거나 빼는 것이 가능하며, 시스템의 성능 변화를 이해하는 데 보다 직관적입니다. 예를 들어, 프론트엔드의 지연 시간이 20ms 증가했다면, 이와 관련된 백엔드의 지연 시간도 대략 20ms 정도 증가한 것을 관찰할 수 있습니다.
- **디버깅 접근 방식**: 평균 지연 시간을 사용하여 문제가 있는 서브시스템을 좁혀낸 후, 필요한 경우 분위수로 전환하여 보다 상세한 분석을 진행할 수 있습니다.
- **히스토그램의 _sum과 _count**: 히스토그램은 지연 시간의 합(_sum)과 개수(_count)도 포함하고 있어, 이를 통해 평균 지연 시간을 계산할 수 있습니다. 예를 들어, `rate(hello_world_latency_seconds_sum[1m]) / rate(hello_world_latency_seconds_count[1m])`를 통해 1분 동안의 평균 지연 시간을 계산할 수 있습니다.

### 요약

분위수는 사용자 경험을 포착하는 데 유용하지만, 시스템의 성능 문제를 디버깅할 때는 평균값을 사용하는 것이 더 나을 수 있습니다. 평균값은 수학적 연산이 가능하고, 시스템의 성능 변화를 이해하기에 더 직관적입니다. 따라서 디버깅 과정에서는 평균 지연 시간을 우선적으로 고려한 후, 필요에 따라 분위수 분석으로 전환하는 것이 좋습니다.

- **서머리(Summary)**:
   - **사용법**: 서머리는 히스토그램과 유사하게 동작하지만, 직접적으로 분위수를 계산합니다. 이는 주로 네트워크 요청 처리 시간이나 서비스 호출 지연과 같은 측정치에 사용됩니다.
   - **특징**: 서머리는 서버 측에서 분위수를 계산하여 제공합니다. 이는 히스토그램과는 다르게, 프로메테우스 서버가 분위수를 계산하는 부담을 덜어줍니다.

## 유닛 테스트

- 메트릭의 유닛 테스트는 코드 변경에 따른 오류를 방지하는 데 중요합니다.
- Python 클라이언트는 `get_sample_value` 함수를 제공하여 카운터 같은 메트릭의 테스트를 지원합니다.

## 계측 대상


### 서비스 계측

#### 1. 온라인 서비스 시스템
- **정의**: 사용자나 다른 서비스가 응답을 기다리는 시스템. 웹 서버나 데이터베이스가 이에 해당합니다.
- **핵심 메트릭 (RED 방법)**:
  - **요청 비율(Request Rate)**: 서버로 들어오는 요청의 비율.
  - **지연 시간(Latency)**: 요청에 대한 응답 시간.
  - **오류 비율(Error Rate)**: 실패한 요청의 비율.
- **팁**: 실패한 요청도 지연 시간 계산에 포함시켜야 합니다.

#### 2. 오프라인 서비스 시스템
- **정의**: 즉각적인 응답을 기다리는 사용자가 없는 배치 처리 시스템.
- **핵심 메트릭 (USE 방법)**:
  - **활용도(Utilization)**: 서비스의 전체 용량 대비 사용량.
  - **포화도(Saturation)**: 작업 대기열의 양.
  - **오류(Errors)**: 발생한 오류의 수.
- **적용 예**: 로그 처리 시스템과 같은 다단계 배치 처리 시스템.

#### 3. 배치 작업
- **정의**: 정기적으로 실행되는 작업. 오프라인 시스템과 유사하지만, 지속적으로 실행되지 않습니다.
- **메트릭 기록**: 작업 실행 시간, 각 단계의 실행 시간, 마지막으로 성공한 시간.
- **도구**: Prometheus Pushgateway, Node Exporter textfile collector 등이 사용됩니다.
- **팁**: 배치 작업의 멱등성(idempotency) 유지가 중요합니다. 멱등성은 동일한 작업을 여러 번 수행해도 결과가 동일하게 유지되는 성질을 말합니다.

### 라이브러리 계측

#### 서비스 내 라이브러리 계측
- **서비스 중심의 계측**: 라이브러리는 각 서비스 내에서 '미니 서비스'처럼 작동합니다. 이들 대부분은 온라인 서빙 시스템, 즉 동기적 함수 호출을 포함합니다.
- **핵심 메트릭**:
  - **요청, 지연 시간, 오류**: 이러한 메트릭은 서비스 전체와 마찬가지로 라이브러리에도 적용됩니다. 특히, 캐시 라이브러리의 경우 총 요청 수와 캐시 미스를 계측해야 합니다.

#### 메트릭 활용 팁
- **실패율 계산**: 전체 및 실패 메트릭을 통해 실패율을 쉽게 계산할 수 있습니다. 성공 및 실패 메트릭의 경우, 먼저 전체 요청 수를 계산해야 합니다.
- **캐시 메트릭**: 캐시의 성공적인 적중(hits)과 전체 요청, 혹은 실패와 전체 요청 수를 추적하는 것이 좋습니다. 전체, 적중 및 미스 메트릭을 모두 사용하는 것도 유용합니다.

#### 추가 메트릭 추천
- **오류 및 로깅 메트릭**: 발생한 모든 오류와 로깅에 대한 메트릭을 추가하는 것이 유리합니다. 로그는 저장 공간 제약으로 인해 몇 일 동안만 보관될 수 있지만, 메트릭을 통해 오랜 시간 동안 로그 라인의 빈도를 파악할 수 있습니다.

#### 스레드 및 작업자 풀 계측
- **계측 항목**: 대기열 크기, 활성 스레드 수, 스레드 제한, 발생한 오류 등을 추적합니다. 이는 오프라인 서빙 시스템과 유사한 계측 방법입니다.

#### 백그라운드 유지 작업 계측
- **정의**: 시간당 몇 번 실행되는 백그라운드 작업들은 사실상 배치 작업으로 간주될 수 있습니다.
- **계측 항목**: 작업 실행 시간, 각 단계의 실행 시간, 마지막으로 성공한 시간 등을 기록합니다.


### 계측 범위

#### 프로메테우스의 효율성과 한계
- 프로메테우스는 효율적인 모니터링 시스템이지만, 처리할 수 있는 메트릭의 양에는 한계가 있습니다.
- 운영 및 자원 비용과 메트릭의 이점을 고려할 때, 특정 계측 전략의 비용이 이득을 초과할 수 있습니다.

#### 일반적인 사용 사례
- 대부분의 경우, 프로메테우스는 상당한 양의 메트릭을 처리할 수 있습니다.
- 예를 들어, 10백만 개의 메트릭을 처리할 수 있는 프로메테우스 서버가 있고, 1,000개의 애플리케이션 인스턴스가 있다고 가정해봅시다. 이 경우, 각 인스턴스에서 새로운 메트릭 하나를 추가하는 것은 자원의 0.01%만을 사용하게 됩니다.
- 이는 개별 메트릭을 수동으로 추가하는 데 큰 부담이 되지 않음을 의미합니다.

#### 산업적 규모에서의 주의점
- 모든 함수의 지속 시간에 대한 메트릭을 자동으로 추가하는 경우와 같이, 광범위한 자동 계측은 리소스 사용량을 빠르게 증가시킬 수 있습니다.
- 요청 유형 및 HTTP URL 별로 세분화된 메트릭은 리소스 사용량의 상당 부분을 차지할 수 있습니다.
- 히스토그램 버킷은 이를 더 확장합니다. 인스턴스 당 백 개의 카디널리티를 가진 메트릭은 프로메테우스 서버 자원의 1%를 차지할 수 있으며, 이는 명확한 이점이 아닙니다.

#### 최적의 리소스 관리 전략
- 프로메테우스 인스턴스에서 가장 큰 10개의 메트릭이 자원 사용량의 절반 이상을 차지하는 경우가 흔합니다.
- 프로메테우스의 리소스 사용량을 관리하려면, 가장 큰 10개의 메트릭에 초점을 맞추는 것이 효과적입니다.
- 일반적으로, 간단한 서비스(예: 캐시)는 총 100개의 메트릭을 가질 수 있으며, 복잡하고 잘 계측된 서비스는 1,000개의 메트릭을 가질 수 있습니다.

#### 결론
- 프로메테우스에서 메트릭을 계측할 때는 필요한 곳에 적절한 수준의 메트릭을 추가하는 것이 중요합니다.
- 너무 많은 메트릭을 무분별하게 추가하는 것은 자원 사용량과 관리 복잡성을 불필요하게 증가시킬 수 있습니다.

## 메트릭 명명 규칙

- 메트릭 명명에는 특정 규칙이 적용됩니다. 예를 들어, snake case를 사용하고, 기본 단위(초, 바이트 등)를 포함하는 것이 좋습니다.

## 퀴즈

## 퀴즈

1. **프로메테우스의 카운터 메트릭은 어떤 특징을 가지고 있나요?**
   A) 값이 감소할 수 있다.
   B) 주로 현재 상태 값을 나타낸다.
   C) 누적된 값을 나타내며, 오직 증가만 한다.
   D) 특정 시점의 값을 나타낸다.

   답변: C) 누적된 값을 나타내며, 오직 증가만 한다.
   이유: 카운터 메트릭은 연속적으로 증가하는 값(예: 웹 사이트 방문 횟수)을 추적하는 데 사용되며, 감소하지 않습니다.

2. **히스토그램에서 '버킷'의 역할은 무엇인가요?**
   A) 메트릭의 저장소를 관리한다.
   B) 데이터 포인트를 분류하여 각 범위에 속하는 샘플 수를 추적한다.
   C) 메트릭의 이름을 정의한다.
   D) 메트릭의 샘플링 빈도를 결정한다.

   답변: B) 데이터 포인트를 분류하여 각 범위에 속하는 샘플 수를 추적한다.
   이유: 히스토그램의 버킷은 샘플들을 다양한 범위(예: 응답 시간 구간)에 따라 분류하고, 각 범위에 속하는 샘플의 수를 추적합니다.

3. **프로메테우스에서 메트릭 명명 시 권장되는 방식은 무엇인가요?**
   A) camelCase를 사용한다.
   B) snake_case를 사용하고 기본 단위를 포함한다.
   C) 대문자와 언더스코어만 사용한다.
   D) 가능한 한 짧고 간결한 이름을 사용한다.

   답변: B) snake_case를 사용하고 기본 단위를 포함한다.
   이유: 프로메테우스는 snake_case 명명 규칙을 사용하며, 메트릭 이름에는 관련된 단위(예: 초, 바이트)를 포함하는 것이 좋습니다.

4. **서비스 계측에서 RED 방법이란 무엇을 의미하나요?**
   A) 리소스, 에러, 데이터
   B) 리퀘스트, 에러, 디버깅
   C) 리퀘스트, 에러, 듀레이션
   D) 리팩토링, 실행, 배포

   답변: C) 리퀘스트, 에러, 듀레이션
   이유: RED 방법은 Request Rate(요청 비율), Error Rate(오류 비율), Duration(지연 시간)을 의미하며, 이는 온라인 서비스 시스템을 계측할 때 주로 사용됩니다.

5. **오프라인 서비스 시스템 계측에서 USE 방법이 포함하는 것은 무엇인가요?**
   A) 사용자, 시스템, 에러
   B) 유틸리티, 속도, 효율
   C) 유틸리제이션, 새츄레이션, 에러
   D) 업데이트, 서비스, 실행

   답변: C) 유틸리제이션, 새츄레이션, 에러
   이유: USE 방법은 Utilization(활용도), Saturation(포화도), Errors(오류)를 의미하며, 오프라인 시스템 계측에 사용됩니다. 이는 시스템의 전체 용량 대비 사용량, 작업 대기열 양, 발생한 오류를 포함합니다.

